name: QA Android UI Tests

on:
  workflow_dispatch:
    inputs:
      appBuildNumber:
        description: "AppBuildNumber. Use 'latest' or build number(e.g 71389)"
        required: true
        default: "latest"
        type: string

      isUpgrade:
        description: "Upgrade test? If true, oldBuildNumber is REQUIRED."
        required: true
        default: false
        type: boolean

      oldBuildNumber:
        description: "For upgrade runs: type the old build number here"
        required: false
        default: ""
        type: string

      enforceAppInstall:
        description: "If you want to run with a lower version than currently on the device, set this value to true."
        required: true
        default: false
        type: boolean

      flavor:
        description: "App flavor."
        required: true
        type: choice
        options:
          - internal release candidate
          - internal beta
          - staging compat
          - experimental
          - column-1
          - column-2
          - column-3
          - debug
          - fdroid
          - production
        default: internal release candidate

      TAGS:
        description: "Tags: '@regression' OR '@TC-8143'."
        required: false
        default: ""
        type: string

      testinyRunName:
        description: "TESTINY_RUN_NAME."
        required: false
        default: ""
        type: string

      androidDeviceId:
        description: "androidDeviceId. Target a specific device. Leave empty for auto."
        required: false
        default: ""
        type: string

permissions:
  contents: read

jobs:
  # Validate user inputs and derive selectors and flavor metadata.
  validate-and-resolve-inputs:
    name: Validate + resolve selectors
    runs-on: ubuntu-latest

    outputs:
      resolvedTestCaseId: ${{ steps.resolve_selector.outputs.testCaseId }}
      resolvedCategory: ${{ steps.resolve_selector.outputs.category }}
      s3Folder: ${{ steps.resolve_flavor.outputs.s3Folder }}
      appId: ${{ steps.resolve_flavor.outputs.appId }}

    steps:
      # Validate upgrade inputs for consistency.
      - name: Validate upgrade inputs
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ inputs.isUpgrade }}" == "true" && -z "${{ inputs.oldBuildNumber }}" ]]; then
            echo "ERROR: oldBuildNumber is REQUIRED when isUpgrade=true"
            exit 1
          fi

      # Parse TAGS into a single selector (testCaseId or category).
      - name: Resolve selector from TAGS
        id: resolve_selector
        shell: bash
        run: |
          set -euo pipefail

          TESTCASE_ID=""
          CATEGORY=""
          TAGS_RAW="${{ inputs.TAGS }}"

          trim() { echo "$1" | xargs; }

          if [[ -n "$(trim "${TAGS_RAW}")" ]]; then
            sel=""
            IFS=',' read -ra parts <<< "${TAGS_RAW}"
            for p in "${parts[@]}"; do
              t="$(trim "$p")"
              if [[ -n "$t" ]]; then
                sel="$t"
                break
              fi
            done

            sel="${sel#@}"
            sel="$(trim "$sel")"

            if [[ "$sel" == *:* ]]; then
              echo "ERROR: TAGS format '@key:value' is not supported yet. Use '@TC-1234' or '@category'."
              exit 1
            fi

            if [[ "$sel" =~ ^TC-[0-9]+$ ]]; then
              TESTCASE_ID="$sel"
            else
              CATEGORY="$sel"
            fi
          fi

          echo "testCaseId=$TESTCASE_ID" >> "$GITHUB_OUTPUT"
          echo "category=$CATEGORY" >> "$GITHUB_OUTPUT"

      # Map flavor to S3 path and Android package id.
      - name: Resolve flavor -> S3_FOLDER + APP_ID
        id: resolve_flavor
        shell: bash
        run: |
          set -euo pipefail

          FLAVOR="$(echo "${{ inputs.flavor }}" | xargs)"
          S3_FOLDER=""
          APP_ID=""

          case "$FLAVOR" in
            "staging compat")
              S3_FOLDER="artifacts/megazord/android/reloaded/staging/compat/"
              APP_ID="com.waz.zclient.dev"
              ;;
            "internal beta")
              S3_FOLDER="artifacts/megazord/android/reloaded/beta/release/"
              APP_ID="com.wire.android.internal"
              ;;
            "internal release candidate")
              S3_FOLDER="artifacts/megazord/android/reloaded/internal/compat/"
              APP_ID="com.wire.internal"
              ;;
            "experimental")
              S3_FOLDER="artifacts/megazord/android/reloaded/staging/compat/"
              APP_ID="com.waz.zclient.dev"
              ;;
            "column-1")
              S3_FOLDER="android/custom/bund/column1/prod/compatrelease/"
              APP_ID="com.wire.android.bund"
              ;;
            "column-2")
              S3_FOLDER="android/custom/bund/column2/prod/compatrelease/"
              APP_ID="com.wire.android.bund.column2"
              ;;
            "column-3")
              S3_FOLDER="android/custom/bund/column3/prod/compatrelease/"
              APP_ID="com.wire.android.bund.column3"
              ;;
            "debug")
              S3_FOLDER="artifacts/megazord/android/reloaded/dev/debug/"
              APP_ID="com.waz.zclient.dev.debug"
              ;;
            "fdroid")
              S3_FOLDER="artifacts/megazord/android/reloaded/fdroid/compatrelease/"
              APP_ID="com.wire"
              ;;
            "production")
              S3_FOLDER="artifacts/megazord/android/reloaded/prod/compatrelease/"
              APP_ID="com.wire"
              ;;
            *)
              echo "ERROR: Unknown flavor: '$FLAVOR'"
              exit 1
              ;;
          esac

          echo "s3Folder=$S3_FOLDER" >> "$GITHUB_OUTPUT"
          echo "appId=$APP_ID" >> "$GITHUB_OUTPUT"

      # Log resolved values for troubleshooting.
      - name: Print resolved values
        shell: bash
        run: |
          set -euo pipefail
          echo "flavor=${{ inputs.flavor }}"
          echo "resolvedTestCaseId=${{ steps.resolve_selector.outputs.testCaseId }}"
          echo "resolvedCategory=${{ steps.resolve_selector.outputs.category }}"

  # Run UI tests on self-hosted Android devices and publish Allure report.
  run-android-ui-tests:
    name: Run Android UI tests
    runs-on:
      - self-hosted
      - Linux
      - X64
      - office
      - android-qa

    needs: validate-and-resolve-inputs
    permissions:
      contents: write

    env:
      AWS_REGION: eu-west-1
      S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
      OP_VAULT: "Test Automation"
      S3_FOLDER: ${{ needs.validate-and-resolve-inputs.outputs.s3Folder }}
      APP_ID: ${{ needs.validate-and-resolve-inputs.outputs.appId }}

    defaults:
      run:
        shell: bash

    steps:
      # Checkout source and set up toolchain.
      - name: Checkout (with submodules)
        uses: actions/checkout@v4
        with:
          clean: true
          submodules: recursive

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: gradle

      - name: Set up Android SDK (ANDROID_HOME + adb)
        uses: android-actions/setup-android@v3

      # Ensure required CLI tools are available on the runner.
      - name: Ensure required tools exist
        run: |
          set -euo pipefail
          command -v adb >/dev/null 2>&1 || { echo "ERROR: adb not found"; exit 1; }
          command -v python3 >/dev/null 2>&1 || { echo "ERROR: python3 not found on this runner"; exit 1; }

          if command -v aws >/dev/null 2>&1; then
            aws --version
            exit 0
          fi

          command -v curl >/dev/null 2>&1 || { echo "ERROR: curl not found"; exit 1; }
          command -v unzip >/dev/null 2>&1 || { echo "ERROR: unzip not found"; exit 1; }
          : "${RUNNER_TEMP:?RUNNER_TEMP not set}"

          echo "aws CLI not found. Installing AWS CLI v2 locally..."
          AWS_ROOT="${RUNNER_TEMP}/awscli"
          ZIP_PATH="${RUNNER_TEMP}/awscliv2.zip"

          rm -rf "${AWS_ROOT}" "${ZIP_PATH}" "${RUNNER_TEMP}/aws"
          mkdir -p "${AWS_ROOT}"

          curl -fsSL -o "${ZIP_PATH}" "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"
          unzip -oq "${ZIP_PATH}" -d "${RUNNER_TEMP}"
          rm -f "${ZIP_PATH}"

          "${RUNNER_TEMP}/aws/install" -i "${AWS_ROOT}" -b "${AWS_ROOT}/bin"
          echo "${AWS_ROOT}/bin" >> "${GITHUB_PATH}"
          export PATH="${AWS_ROOT}/bin:${PATH}"

          aws --version

      # Configure AWS access to download APKs from S3.
      - name: Configure AWS credentials (for S3)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-1

      # Resolve and download new/old APKs for the run.
      - name: Download APK(s) from S3
        id: download_apks
        env:
          APP_BUILD_NUMBER: ${{ inputs.appBuildNumber }}
          IS_UPGRADE: ${{ inputs.isUpgrade }}
          OLD_BUILD_NUMBER: ${{ inputs.oldBuildNumber }}
        run: |
          set -euo pipefail
          : "${S3_BUCKET:?ERROR: Missing secret AWS_S3_BUCKET}"
          : "${S3_FOLDER:?ERROR: S3_FOLDER missing}"

          aws s3api list-objects-v2 \
            --bucket "${S3_BUCKET}" \
            --prefix "${S3_FOLDER}" \
            --query "Contents[?ends_with(Key, '.apk')].Key" \
            --output json > "${RUNNER_TEMP}/apk_keys.json"

          python3 - <<'PY' > "${RUNNER_TEMP}/apk_env.txt"
          import json, os, re, sys

          keys_path = os.path.join(os.environ["RUNNER_TEMP"], "apk_keys.json")
          try:
            data = json.load(open(keys_path, "r", encoding="utf-8"))
          except Exception:
            data = []
          if not isinstance(data, list):
            data = []

          apks = [k for k in data if isinstance(k, str) and k.lower().endswith(".apk")]
          if not apks:
            print("ERROR: No .apk files found in this prefix.", file=sys.stderr)
            sys.exit(1)

          app_build = (os.environ.get("APP_BUILD_NUMBER") or "").strip()
          is_upgrade = (os.environ.get("IS_UPGRADE", "false").strip().lower() == "true")
          old_input = (os.environ.get("OLD_BUILD_NUMBER") or "").strip()

          def parse_version(fname: str):
            m = re.search(r"-v(\d+)\.(\d+)\.(\d+)-(\d+)", fname)
            if m:
              return (int(m.group(1)), int(m.group(2)), int(m.group(3)), int(m.group(4)))
            m = re.search(r"-v(\d+)\.(\d+)\.(\d+)-fdroid", fname)
            if m:
              return (int(m.group(1)), int(m.group(2)), int(m.group(3)), 0)
            m = re.search(r"-v(\d+)\.(\d+)\.(\d+)", fname)
            if m:
              return (int(m.group(1)), int(m.group(2)), int(m.group(3)), 0)
            return None

          def build_label(fname: str):
            m = re.search(r"-v(\d+\.\d+\.\d+-\d+)", fname)
            if m: return m.group(1)
            m = re.search(r"-v(\d+\.\d+\.\d+)-fdroid", fname)
            if m: return m.group(1)
            m = re.search(r"-v(\d+\.\d+\.\d+)", fname)
            if m: return m.group(1)
            return ""

          def pick_by_substring(substr: str):
            if not substr:
              return None
            for k in apks:
              if substr in k.split("/")[-1]:
                return k
            return None

          def pick_by_filename(filename: str):
            if not filename:
              return None
            for k in apks:
              if k.split("/")[-1] == filename:
                return k
            return None

          parsed = []
          for k in apks:
            pv = parse_version(k.split("/")[-1])
            if pv is not None:
              parsed.append((pv, k))
          parsed.sort(key=lambda x: x[0])

          latest_key = parsed[-1][1] if parsed else apks[-1]
          second_latest_key = parsed[-2][1] if len(parsed) >= 2 else None

          def normalize_direct(s: str):
            s = s.strip()
            if s.startswith("s3://"):
              # s3://bucket/key...
              parts = s.split("/", 3)
              return parts[3] if len(parts) >= 4 else ""
            return s.lstrip("/")

          new_key = None
          old_key = None

          # Direct .apk input: allow s3://..., key..., or filename.apk
          if app_build.lower().endswith(".apk"):
            direct = normalize_direct(app_build)
            if "/" in direct:
              new_key = direct
            else:
              new_key = pick_by_filename(direct) or pick_by_substring(direct)

            if is_upgrade:
              if old_input.lower().endswith(".apk"):
                od = normalize_direct(old_input)
                old_key = (od if "/" in od else (pick_by_filename(od) or pick_by_substring(od)))
              else:
                old_key = pick_by_substring(old_input) if old_input else second_latest_key

          elif app_build == "latest":
            new_key = latest_key
            if is_upgrade:
              old_key = pick_by_substring(old_input) if old_input else second_latest_key

          else:
            new_key = pick_by_substring(app_build)
            if is_upgrade:
              if not old_input:
                print("ERROR: isUpgrade=true but oldBuildNumber is empty.", file=sys.stderr)
                sys.exit(1)
              old_key = pick_by_substring(old_input)

          if not new_key:
            print(f"ERROR: Could not resolve NEW apk for appBuildNumber='{app_build}'", file=sys.stderr)
            sys.exit(1)
          if is_upgrade and not old_key:
            print("ERROR: Upgrade requested but OLD apk could not be resolved.", file=sys.stderr)
            sys.exit(1)

          new_name = new_key.split("/")[-1]
          old_name = old_key.split("/")[-1] if old_key else ""

          print(f"NEW_S3_KEY={new_key}")
          print(f"OLD_S3_KEY={old_key or ''}")
          print(f"NEW_APK_NAME={new_name}")
          print(f"OLD_APK_NAME={old_name}")
          print(f"REAL_BUILD_NUMBER={build_label(new_name)}")
          print(f"OLD_BUILD_NUMBER={build_label(old_name) if old_name else ''}")
          PY

          # Make vars available now + future steps
          set -a
          source "${RUNNER_TEMP}/apk_env.txt"
          set +a
          cat "${RUNNER_TEMP}/apk_env.txt" >> "$GITHUB_ENV"
          cat "${RUNNER_TEMP}/apk_env.txt" >> "$GITHUB_OUTPUT"

          NEW_APK_PATH="${RUNNER_TEMP}/Wire.apk"
          echo "NEW_APK_PATH=${NEW_APK_PATH}" >> "$GITHUB_ENV"
          aws s3 cp "s3://${S3_BUCKET}/${NEW_S3_KEY}" "${NEW_APK_PATH}" --only-show-errors
          test -s "${NEW_APK_PATH}"

          if [[ "${IS_UPGRADE}" == "true" ]]; then
            OLD_APK_PATH="${RUNNER_TEMP}/Wire.old.apk"
            echo "OLD_APK_PATH=${OLD_APK_PATH}" >> "$GITHUB_ENV"
            aws s3 cp "s3://${S3_BUCKET}/${OLD_S3_KEY}" "${OLD_APK_PATH}" --only-show-errors
            test -s "${OLD_APK_PATH}"
          fi

      # Pick target devices and set up sharding metadata.
      - name: Detect target device(s)
        run: |
          set -euo pipefail

          DEVICE_LINES="$(adb devices | awk 'NR>1 && $2=="device"{print $1}')"
          if [[ -z "${DEVICE_LINES}" ]]; then
            echo "ERROR: No online Android devices found."
            exit 1
          fi

          TARGET="${{ inputs.androidDeviceId }}"
          if [[ -n "$TARGET" ]]; then
            if ! printf '%s\n' "$DEVICE_LINES" | grep -qx "$TARGET"; then
              echo "ERROR: androidDeviceId '$TARGET' not found in adb devices."
              exit 1
            fi
            DEVICE_LIST="$TARGET"
          else
            DEVICE_LIST="$(printf '%s\n' "$DEVICE_LINES" | xargs)"
          fi

          DEVICE_COUNT="$(wc -w <<<"${DEVICE_LIST}" | tr -d ' ')"

          echo "DEVICE_LIST=${DEVICE_LIST}" >> "$GITHUB_ENV"
          echo "DEVICE_COUNT=${DEVICE_COUNT}" >> "$GITHUB_ENV"
          echo "Using ${DEVICE_COUNT} device(s)"

      # Install APKs and stage upgrade artifacts on devices.
      - name: Install APK(s) on device(s)
        run: |
          set -euo pipefail
          : "${DEVICE_LIST:?DEVICE_LIST missing}"
          : "${APP_ID:?APP_ID missing}"
          : "${NEW_APK_PATH:?NEW_APK_PATH missing}"

          NEW_APK_DEVICE_PATH="/data/local/tmp/Wire.new.apk"
          OLD_APK_DEVICE_PATH="/data/local/tmp/Wire.old.apk"
          echo "NEW_APK_DEVICE_PATH=${NEW_APK_DEVICE_PATH}" >> "$GITHUB_ENV"
          echo "OLD_APK_DEVICE_PATH=${OLD_APK_DEVICE_PATH}" >> "$GITHUB_ENV"

          INSTALL_FLAGS="-r"
          if [[ "${{ inputs.enforceAppInstall }}" == "true" ]]; then
            INSTALL_FLAGS="-r -d"
          fi

          PACKAGES=(
            "com.wire"
            "com.waz.zclient.dev"
            "com.wire.internal"
            "com.wire.android.internal"
            "com.wire.android.bund"
            "com.wire.android.bund.column2"
            "com.wire.android.bund.column3"
            "com.waz.zclient.dev.debug"
          )

          read -ra DEVICES <<< "${DEVICE_LIST}"
          for SERIAL in "${DEVICES[@]}"; do
            ADB="adb -s ${SERIAL}"
            ${ADB} wait-for-device

            # Clean baseline: uninstall known package ids if present
            INSTALLED="$(${ADB} shell pm list packages || true)"
            for pkg in "${PACKAGES[@]}"; do
              if echo "${INSTALLED}" | grep -qx "package:${pkg}"; then
                ${ADB} uninstall "${pkg}" || true
              fi
            done

            if [[ "${{ inputs.isUpgrade }}" == "true" ]]; then
              : "${OLD_APK_PATH:?OLD_APK_PATH missing for upgrade}"
              ${ADB} shell rm -f "${NEW_APK_DEVICE_PATH}" "${OLD_APK_DEVICE_PATH}" || true
              ${ADB} push "${OLD_APK_PATH}" "${OLD_APK_DEVICE_PATH}" >/dev/null
              ${ADB} push "${NEW_APK_PATH}" "${NEW_APK_DEVICE_PATH}" >/dev/null
              ${ADB} install ${INSTALL_FLAGS} "${OLD_APK_PATH}"
            else
              ${ADB} install ${INSTALL_FLAGS} "${NEW_APK_PATH}"
            fi

            if ! ${ADB} shell pm list packages | grep -qx "package:${APP_ID}"; then
              echo "ERROR: '${APP_ID}' not installed on ${SERIAL}."
              exit 1
            fi
          done

      # Fetch runtime secrets needed by tests.
      - name: Install 1Password CLI
        uses: 1password/install-cli-action@v2

      - name: Fetch secrets.json (runtime only)
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
        run: |
          set -euo pipefail
          if [[ -z "${OP_SERVICE_ACCOUNT_TOKEN:-}" ]]; then
            echo "ERROR: Missing OP_SERVICE_ACCOUNT_TOKEN secret"
            exit 1
          fi

          echo "::add-mask::${OP_SERVICE_ACCOUNT_TOKEN}"

          chmod +x ./gradlew

          SECRETS_FILE="${RUNNER_TEMP}/secrets.json"
          export SECRETS_JSON_PATH="${SECRETS_FILE}"
          echo "SECRETS_JSON_PATH=${SECRETS_FILE}" >> "$GITHUB_ENV"

          ./gradlew :tests:testsSupport:fetchSecrets \
            --no-daemon \
            --no-configuration-cache \
            --quiet \
            -PsecretsJsonPath="${SECRETS_FILE}" \
            -PopVault="${OP_VAULT}"

          test -s "${SECRETS_FILE}"
          chmod 600 "${SECRETS_FILE}"
          echo "OK: secrets.json created at ${SECRETS_FILE}"

      # Build the instrumentation test APK.
      - name: Build test APK (assemble)
        run: |
          set -euo pipefail
          ./gradlew :tests:testsCore:assembleDebugAndroidTest --no-daemon --no-configuration-cache

      # Execute UI tests with per-device sharding.
      - name: Run UI tests (one shard per device)
        env:
          RESOLVED_TESTCASE_ID: ${{ needs.validate-and-resolve-inputs.outputs.resolvedTestCaseId }}
          RESOLVED_CATEGORY: ${{ needs.validate-and-resolve-inputs.outputs.resolvedCategory }}
        run: |
          set -euo pipefail
          : "${DEVICE_LIST:?DEVICE_LIST missing}"
          : "${DEVICE_COUNT:?DEVICE_COUNT missing}"

          GRADLE_ARGS=(
            ":tests:testsCore:connectedDebugAndroidTest"
            "--no-daemon"
            "--no-configuration-cache"
          )

          if [[ -n "${RESOLVED_TESTCASE_ID}" ]]; then
            GRADLE_ARGS+=("-Pandroid.testInstrumentationRunnerArguments.testCaseId=${RESOLVED_TESTCASE_ID}")
          fi
          if [[ -n "${RESOLVED_CATEGORY}" ]]; then
            GRADLE_ARGS+=("-Pandroid.testInstrumentationRunnerArguments.category=${RESOLVED_CATEGORY}")
          fi
          if [[ "${{ inputs.isUpgrade }}" == "true" ]]; then
            GRADLE_ARGS+=("-Pandroid.testInstrumentationRunnerArguments.newApkPath=${NEW_APK_DEVICE_PATH}")
            GRADLE_ARGS+=("-Pandroid.testInstrumentationRunnerArguments.oldApkPath=${OLD_APK_DEVICE_PATH}")
          fi

          NUM_SHARDS="${DEVICE_COUNT}"
          if [[ -n "${RESOLVED_TESTCASE_ID}" ]]; then
            NUM_SHARDS="1"
          fi

          read -ra DEVICES <<< "${DEVICE_LIST}"
          echo "Sharding: numShards=${NUM_SHARDS}, deviceCount=${DEVICE_COUNT}"

          pids=()
          shard_index=0

          for SERIAL in "${DEVICES[@]}"; do
            (
              set -euo pipefail
              export ANDROID_SERIAL="${SERIAL}"
              export GRADLE_USER_HOME="${RUNNER_TEMP}/gradle-${SERIAL}"

              ./gradlew "${GRADLE_ARGS[@]}" \
                "-Pandroid.testInstrumentationRunnerArguments.numShards=${NUM_SHARDS}" \
                "-Pandroid.testInstrumentationRunnerArguments.shardIndex=${shard_index}"
            ) &
            pids+=("$!")
            shard_index=$((shard_index + 1))
          done

          failed=0
          for pid in "${pids[@]}"; do
            if ! wait "$pid"; then
              failed=1
            fi
          done

          if [[ "$failed" -ne 0 ]]; then
            echo "ERROR: One or more shards failed."
            exit 1
          fi

