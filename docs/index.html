<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
        
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css">
        <title>ADR Viewer - wire-android</title>

        <style type="text/css">
            body {
                display: grid;
                width: auto;
                height: auto;
                align-items: center;
                justify-items: center;
                grid-template-rows: 2fr minmax(80%, auto) 2fr;
            }

            @media only screen and (min-width: 1025px) {
                body {
                    grid-template-columns: 1fr 3fr 1fr;
                }

                header, .panel-group, footer {
                    grid-column: 2;
                }
            }

            .panel-group {
                width: 100%
            }

            .panel-heading.adr-accepted {
                background-color: lightgreen;
            }

            .panel-heading.adr-superseded {
                background-color: lightgrey;
            }

            .panel-heading.adr-amended {
                background-color: yellow;
            }

            .panel-heading.adr-unknown {
                background-color: white;
            }

            .panel-heading.adr-pending {
                background-color: lightblue;
            }

            .adr-superseded > .panel-title > a {
                text-decoration: line-through;
            }

            .adr-icon {
                float: right;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>ADR Viewer - wire-android</h1>
        </header>
        <div class="panel-group">
            
            <div class="panel panel-default">
                <div class="panel-heading adr-unknown">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" href="#collapse0">Decision record template by Michael Nygard</a>

                        
                        <i class="adr-icon fas fa-fw fa-question"></i>
                        

                    </h4>
                </div>
                <div id="collapse0" class="panel-collapse collapse">
                    <div class="panel-body"><h1>Decision record template by Michael Nygard</h1>
<p>This is the template in <a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions">Documenting architecture decisions - Michael Nygard</a>.
You can use <a href="https://github.com/npryce/adr-tools">adr-tools</a> for managing the ADR files.</p>
<p>In each ADR file, write these sections:</p>
<h1>Title</h1>
<h2>Status</h2>
<p>What is the status, such as proposed, accepted, rejected, deprecated, superseded, etc.?</p>
<h2>Context</h2>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
<h2>Decision</h2>
<p>What is the change that we're proposing and/or doing?</p>
<h2>Consequences</h2>
<p>What becomes easier or more difficult to do because of this change?</p>
</div>
                </div>
            </div>
            
            <div class="panel panel-default">
                <div class="panel-heading adr-accepted">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" href="#collapse1">1. Record architecture decisions</a>

                        
                        <i class="adr-icon fas fa-fw fa-check"></i>
                        

                    </h4>
                </div>
                <div id="collapse1" class="panel-collapse collapse">
                    <div class="panel-body"><h1>1. Record architecture decisions</h1>
<p>Date: 2024-08-05</p>
<h2>Status</h2>
<p>Accepted</p>
<h2>Context</h2>
<p>We agreed in the past to use ADR's, but we lost track of it as we were using confluence to keep
them. This concern was raised in the last collective, and we need to decide how to proceed.</p>
<h2>Decision</h2>
<p>We will use Architecture Decision Records in the code and as part of the review process.
We will use the <a href="0000-template-lightway-adr.md">Lightway ADR template</a> to keep the ADRs simple and
easy to maintain.</p>
<h2>Consequences</h2>
<ul>
<li>We need to add a new folder to the repository, <code>docs/adr</code>, to keep the architecture decision
records.</li>
<li>Whenever a new refactoring or library is introduced, a new ADR should be created.</li>
<li>You can always request in the Pull request review process to add a new ADR, if you think it's
necessary.</li>
</ul>
</div>
                </div>
            </div>
            
            <div class="panel panel-default">
                <div class="panel-heading adr-accepted">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" href="#collapse2">2. Calling activity refactor</a>

                        
                        <i class="adr-icon fas fa-fw fa-check"></i>
                        

                    </h4>
                </div>
                <div id="collapse2" class="panel-collapse collapse">
                    <div class="panel-body"><h1>2. Calling activity refactor</h1>
<p>Date: 2024-08-01</p>
<h2>Status</h2>
<p>Accepted</p>
<h2>Context</h2>
<p>To support a second incoming call we need to refactor the code so we can handle the ongoing content
context, without losing the current context.</p>
<p>This is a retroactive decision record implemented
on https://github.com/wireapp/wire-android/pull/3264</p>
<h2>Decision</h2>
<p>Create 2 separate activities, one for the Incoming/Outgoing calls and another for the ongoing call.
In this way, we can keep the context of the ongoing call and handle the incoming/outgoing calls.</p>
<p>The design and interaction will look like this:</p>
<p>&lt;img src=&quot;https://github.com/user-attachments/assets/66f19cce-c2bc-4777-a0eb-b5cda035df8a&quot;/&gt;</p>
<h2>Consequences</h2>
<ul>
<li>StartingActivity will handle Incoming and Outgoing calls content, these contents are disposable
and can be recreated when receiving a new call.</li>
<li>OngoingCallActivity will handle the ongoing call content, this content is not disposable and
should be kept during the call.</li>
</ul>
</div>
                </div>
            </div>
            
            <div class="panel panel-default">
                <div class="panel-heading adr-accepted">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" href="#collapse3">3. Use parameterizable tests in JUnit5</a>

                        
                        <i class="adr-icon fas fa-fw fa-check"></i>
                        

                    </h4>
                </div>
                <div id="collapse3" class="panel-collapse collapse">
                    <div class="panel-body"><h1>3. Use parameterizable tests in JUnit5</h1>
<p>Date: 2024-08-05</p>
<h2>Status</h2>
<p>Accepted</p>
<h2>Context</h2>
<p>Sometimes we need to write multiple tests for the same scenario, changing only the input values.</p>
<h2>Decision</h2>
<p>We will use parameterizable tests in JUnit5 to avoid writing multiple tests for the same scenario.</p>
<h2>Consequences</h2>
<ul>
<li>Introduction of <code>@ParameterizedTest</code> annotation in the test class
and <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">library</a>.</li>
<li>The test method will receive the parameters as arguments.</li>
</ul>
</div>
                </div>
            </div>
            
            <div class="panel panel-default">
                <div class="panel-heading adr-accepted">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" href="#collapse4">4. Deeplink handling refactor</a>

                        
                        <i class="adr-icon fas fa-fw fa-check"></i>
                        

                    </h4>
                </div>
                <div id="collapse4" class="panel-collapse collapse">
                    <div class="panel-body"><h1>4. Deeplink handling refactor</h1>
<p>Date: 2024-09-06</p>
<h2>Status</h2>
<p>Accepted</p>
<h2>Context</h2>
<p>The existing implementation of deeplink handling within our ViewModel is characterized by complex,
bulky logic that makes maintenance and scalability challenging. Current handling involves redundant
checks for each deeplink type and duplicated error logging. Additionally, the logic to handle toast
errors for deeplinks requiring authorization and the management of user session state during calls
(to prevent account switching) are not centralized, leading to repeated code and scattered handling
across components.</p>
<h2>Decision</h2>
<p>We have decided to refactor the existing handleDeepLink function in the ViewModel by consolidating
the URI deeplink processing logic into a dedicated class, DeepLinkProcessor. This class will now
centralize the interpretation and validation of deeplinks, and manage user session states more
effectively, including checks for ongoing calls before allowing account switches. The
DeepLinkProcessor will handle:</p>
<ul>
<li>Duplicate checks and error logging by centralizing deeplink type verification.</li>
<li>Displaying toast errors when deeplink operations require user authorization and preventing
operations during calls.</li>
<li>Secure and condition-based account switching.</li>
</ul>
<h2>Consequences</h2>
<ol>
<li><p>Reduced Duplication: Centralizing deeplink handling reduces duplicated logic across the
application, especially for checking deeplink types and logging errors, ensuring a cleaner
codebase.</p>
</li>
<li><p>Centralized Authorization Management: Toast messages to inform users about the need for
authorization if they attempt to access resources that require authentication are managed
centrally, enhancing user experience and security.</p>
</li>
<li><p>Enhanced Call State Management: The new implementation prevents account switching during active
calls by checking the user's call status directly within DeepLinkProcessor. This is vital for
maintaining session integrity and user experience.</p>
</li>
<li><p>Improved Error Handling: By centralizing error handling and response mechanisms, the application
can more effectively manage and respond to deeplink processing errors, providing a more robust
and fault-tolerant system.</p>
</li>
<li><p>Streamlined Testing and Maintenance: With deeplink logic isolated in a single class, testing
becomes more focused and efficient, allowing for targeted testing strategies and easier
maintenance.</p>
</li>
</ol>
<p>This decision involves careful re-engineering of the deeplink processing mechanisms to ensure
compatibility and functionality across all current and potential future deeplink scenarios,
requiring comprehensive testing and validation to ensure seamless integration.</p>
</div>
                </div>
            </div>
            
            <div class="panel panel-default">
                <div class="panel-heading adr-accepted">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" href="#collapse5">5. Conversation list composables refactor</a>

                        
                        <i class="adr-icon fas fa-fw fa-check"></i>
                        

                    </h4>
                </div>
                <div id="collapse5" class="panel-collapse collapse">
                    <div class="panel-body"><h1>5. Conversation list composables refactor</h1>
<p>Date: 2024-10-01</p>
<h2>Status</h2>
<p>Accepted</p>
<h2>Context</h2>
<p>Conversation-list-related composables and screens (all conversations, archive) are overly
complicated and have many leftovers after bottom tabs and multiple refactors,
so in order to implement pagination, it's better to make a cleanup first.</p>
<h2>Decision</h2>
<p>Simplify and unify composables related to creating screens that show conversation lists.
Remove old, unused code, like things that were implemented in order to make the bottom tabs or code
leftover from previous refactors, and update to make it more readable, reusable and maintainable.
Make it more similar to what we have in other places - instead of having complicated &quot;routers&quot; or
&quot;bridges&quot;, just create &quot;content&quot; composable that can be used on multiple screens,
but with the intention that common <code>ViewModel</code>s are incorporated into this content composable,
so that they do not have to be added each time, but make it possible to generate previews.
Also, make use of <code>AssistedInject</code> to reduce the number of functions and <code>LaunchedEffect</code>s needed.</p>
<h2>Consequences</h2>
<ul>
<li><code>ConversationRouterHomeBridge</code> is now replaced with simpler <code>ConversationsScreenContent</code>,
which is a single composable to be used to create multiple screens that show conversation lists.</li>
<li><code>ConversationListViewModel</code> uses <code>AssistedInject</code> to provide <code>ConversationsSource</code> and a <code>Flow</code>
of search query <code>String</code>s directly in constructor instead of doing it using multiple functions.</li>
<li><code>ConversationListViewModel</code> and <code>ConversationCallListViewModel</code> are injected using unique keys,
so that for each <code>ConversationsSource</code> there is a separate <code>ViewModel</code>. Thanks to that, together
with assisted injection, they are now dedicated to each type which makes it easier to maintain,
debug and even use on the same screen if needed.</li>
<li>Both mentioned <code>ViewModel</code>s are now also interfaces that are implemented by the respective
<code>ConversationListViewModelImpl</code> and <code>ConversationCallListViewModelImpl</code> and &quot;preview&quot; versions
of these interfaces are also created to make it possible to generate composable previews.</li>
</ul>
</div>
                </div>
            </div>
            
            <div class="panel panel-default">
                <div class="panel-heading adr-accepted">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" href="#collapse6">6. Simplified enterprise login</a>

                        
                        <i class="adr-icon fas fa-fw fa-check"></i>
                        

                    </h4>
                </div>
                <div id="collapse6" class="panel-collapse collapse">
                    <div class="panel-body"><h1>6. Simplified enterprise login</h1>
<p>Date: 2025-01-23</p>
<h2>Status</h2>
<p>Accepted</p>
<h2>Context</h2>
<p>Starting (potentially) from Android 4.12.x the app will support the new enterprise login flows, this means in practice that the app needs to support both flows current/old.</p>
<h3>The current flow (old)</h3>
<p>Customers configure their setup manually in their backend.
The user experience for this makes the user selects manually which flow they must use by going to the correct screens, i.e. going to the tab and select login with SSO code, or login with email, or use a deeplink to load the on premise configuration, and then select the correct flow.</p>
<h3>The new flow</h3>
<p>Customers, via team settings and Back-office tools, will be able to load this config to facilitate the decision of which flow the user must use. This will make the app, in conjunction with the backend, decide for the user which path/flow they must use to login by just having one input field, “email or SSO code”.
The adoption won’t be automatically via deprecation, hence the need to support both flows for some time. To clarify a bit how this looks in practice for the code we have, how this will be implemented, a high level look of the two flows living together, the following diagram can be used.</p>
<h2>Decision</h2>
<p>We will keep both flows, the current as-is and the new one, being the app able to decide which one to use based on the configuration received from the backend.</p>
<pre><code class="language-mermaid">%%{
  init: {
    'theme': 'neutral'
  }
}%%

flowchart LR
    z((App loads&lt;/br&gt; BE/API context)) --&gt; di
    di{BE supports &lt;/br&gt;API &gt;= 8 ?}:::someclass -- Yes --&gt; a1
    di -- No&lt;/br&gt;OR Authenticated Proxy --&gt; b1
    classDef someclass fill:#f96
    subgraph new_flow
      a0@{ shape: braces, label: &quot;These flows are selected by the app and the BE&quot; }
      a1[StartLoginScreen &lt;/br&gt;'Enter email or SSO code'] -- looks like SSO code --&gt; a2[Go to SSO flow path 6-7] 
      a1 -- Looks like an email? --&gt; a3[BE replies which path to go 1-4]
    end
    subgraph current_flow
      b0@{ shape: braces, label: &quot;These flows are selected manually by the user&quot; }
      b1[WelcomeScreen] --&gt; b2[LoginEmailScreen]
      b1 --&gt; b3[LoginWithSSOCodeScreen]
    end
</code></pre>
<h2>Consequences</h2>
<ul>
<li>The code base will have some duplication for some time, but this will be removed when the old flow is deprecated.</li>
<li>To select the correct flow, the app will need to load the BE context, based on the API version, and then decide which flow to use.</li>
<li>The navigation, entry point will need to be dynamic, based on the flow selected.</li>
</ul>
</div>
                </div>
            </div>
            
            <div class="panel panel-default">
                <div class="panel-heading adr-accepted">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" href="#collapse7">7. Introducing UIAutomator for integrated testing</a>

                        
                        <i class="adr-icon fas fa-fw fa-check"></i>
                        

                    </h4>
                </div>
                <div id="collapse7" class="panel-collapse collapse">
                    <div class="panel-body"><h1>7. Introducing UIAutomator for integrated testing</h1>
<p>Date: 2025-05-06</p>
<h2>Status</h2>
<p>Accepted</p>
<h2>Context</h2>
<p>QA wants to migrate from Appium to a new framework to run tests and being closed to the source code that we are testing.
The tests nowadays are running on an emulator with an apk. After meeting the QA we evaluated options, Espresso and UIAutomator.</p>
<h2>Decision</h2>
<p>UIAutomator seems to be the best option for us, as it is a framework that is already in the Android SDK and it is more flexible than Espresso, this last one is more limited to the app under test because of mocks and stubs.
We will create a new module(s) for testing purposes, and we will use the UIAutomator framework to run the tests, common logic can be extracted and shared between tests modules in case we want to parallelize the tests in the future.</p>
<h2>Consequences</h2>
<p>The new structure of the project will be as follows:</p>
<pre><code>wire-android
├── app
│   ├── ...
├── core
│   ├── ...
├── features
│   ├── ...
├── tests
│   ├── ...
│   ├── testsCore
│   ├── testsSupport
└── build.gradle.kts
</code></pre>
</div>
                </div>
            </div>
            
            <div class="panel panel-default">
                <div class="panel-heading adr-accepted">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" href="#collapse8">8. Introducing Enterprise Mobility Management (EMM) Capabilities</a>

                        
                        <i class="adr-icon fas fa-fw fa-check"></i>
                        

                    </h4>
                </div>
                <div id="collapse8" class="panel-collapse collapse">
                    <div class="panel-body"><h1>8. Introducing Enterprise Mobility Management (EMM) Capabilities</h1>
<p>Date: 2025-10-15</p>
<h2>Status</h2>
<p>Accepted</p>
<h2>Context</h2>
<p>As a requirement for some of our business cases, we need to introduce Enterprise Mobility Management (EMM) capabilities into our Android application. EMM solutions help organizations manage and secure mobile devices, applications, and data.
To implement EMM capabilities, we want to add support for the following features:</p>
<ul>
<li>Backend setup using managed configurations, the ability for the app to connect by default to a specific backend.</li>
<li>SSO Capabilities, allowing users to authenticate with a default sso code configuration.</li>
</ul>
<h2>Decision</h2>
<p>This was implemented by following the guidelines provided by Google for adding EMM capabilities to Android applications. The steps taken were:</p>
<ol>
<li><strong>Manifest Changes</strong>: Updated the AndroidManifest.xml to include the necessary permissions and metadata</li>
<li><strong>Managed Configurations</strong>: Implemented support for managed configurations to allow IT administrators to configure the app remotely.</li>
<li><strong>SSO Integration</strong>: Integrated SSO capabilities to allow seamless authentication for users within an enterprise environment.</li>
<li><strong>Testing</strong>: Conducted thorough testing to ensure that the EMM features work as</li>
</ol>
<h2>Consequences</h2>
<ul>
<li>The app now support EMM capabilities, by making use of <code>RestrictionsManager</code> component to retrieve managed configurations and apply them accordingly.</li>
<li>The app reads the managed configurations and applies them to set the default backend and SSO settings.</li>
<li>The app resolves using DI the backend and SSO settings from the managed configurations if available, otherwise it falls back to the app default settings.</li>
</ul>
<pre><code class="language-mermaid">---
config:
layout: dagre
theme: neutral
---
flowchart TD
A([&quot;App Start&quot;]) --&gt; B[&quot;ManagedConfigurationsManager&quot;]
B --&gt; C{&quot;Managed Configurations Available?&quot;}
C -- Yes --&gt; D[&quot;Retrieve Managed Configs&quot;]
D --&gt; E{&quot;Valid Configuration?&quot;}
E -- Yes --&gt; F[&quot;Use as DI Defaults&quot;]
E -- No/Error --&gt; G[&quot;Load default.json&quot;]
C -- No --&gt; G
G --&gt; H[&quot;Use App Defaults via DI&quot;]
P([&quot;App Resume&quot;]) --&gt; B
R([&quot;Broadcast Receiver Triggered&quot;]) --&gt; L[&quot;ManagedConfigurationReceiver&quot;]
L --&gt; B
F --&gt; J[&quot;ViewModels Inject non scoped values from ManagedConfigurationsManager&quot;]
H --&gt; J
J@{ shape: card}
style A fill:#C8E6C9
style B fill:#BBDEFB
style P fill:#C8E6C9
style R fill:#C8E6C9
style J fill:#BBDEFB
</code></pre>
</div>
                </div>
            </div>
            
        </div>
        <footer>
            Generated with &lt;3 using ADR Viewer
        </footer>
        
    </body>
</html>